{"title":"linuxKernel-3","date":"2021-05-24T08:26:34.000Z","date_formatted":{"ll":"2021年5月24日","L":"2021/05/24","MM-DD":"05-24"},"link":"2021/05/24/linuxKernel-3","tags":["linux"],"updated":"2021-05-29T02:59:39.877Z","content":"<p>Linux 0.1x系统中使用了两种汇编器：<strong>as86汇编器（16位代码）和gas汇编器</strong>。</p>\n<p><em>as86</em>： Linux系统仅用它来创建</p>\n<ul>\n<li>16位的启动引导扇区程序boot/bootsect.s</li>\n<li>实模式下初始设置程序boot/setup.s的二进制执行代码。</li>\n</ul>\n<h1 id=\"as86汇编语言的语法\">as86汇编语言的语法<a title=\"#as86汇编语言的语法\" href=\"#as86汇编语言的语法\"></a></h1>\n<p>汇编命令行的基本格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">as [选项] -o objfile srcfile</span><br></pre></td></tr></table></figure>\n<ul>\n<li>赋值语句：标识符后跟一个等号，再跟一个表达式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOTSEG &#x3D; 0x07c0</span><br></pre></td></tr></table></figure>\n<ul>\n<li>伪操作语句：通常不会产生任何代码，由伪操作码和0个或多个操作数组成。每个操作码都由一个点字符 ‘. ’开始，其本身就是一个特殊的符号，表示编译过程中的位置计数器，其值就是点符号出现处机器指令第一个字节的地址。</li>\n</ul>\n<p>汇编器编译产生的目标文献objfile通常包括：</p>\n<ol>\n<li>正文段（.text）</li>\n<li>数据段（.data）</li>\n<li>未初始化数据段（.bss）</li>\n</ol>\n<p>1和2 都是已初始化的过程，1包含程序的执行代码和只读数据，2包含有可读/写的数据。</p>\n<p>‘!’ 或者 ‘;’ 开始的语句都是注释文字。</p>\n<p>'.globl’伪操作符用于定义随后的标号标识符是<strong>外部的或者全局的</strong></p>\n<p><strong>CS：IP</strong> 中CS是指代码段寄存器，IP是指针寄存器，在8086中几，任意时刻，CPU都是执行的CS：IP内容在当作指令。</p>\n<p>mov指令的顺序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, cs !将cs的值赋给ax</span><br></pre></td></tr></table></figure>\n<p>ds： 数据寄存器</p>\n<p>ss： 栈寄存器</p>\n<p>es：扩展段寄存器</p>\n<p><strong>间接的操作数需要使用方括号对</strong>，类比于传址和传值，直接寄存器是地址，加入方括号对是该地址的值。</p>\n<p>操作立即数的时候，需要加一个#</p>\n<p><em>几个常用的寄存器:</em></p>\n<ul>\n<li>AX：寄存器称为累加器，常用于存放算术、逻辑运算中的操作数或结果。另外，所有的I/O指令都要使用累加器与外设接口传递数据。</li>\n<li>BX：寄存器称为基址寄存器，常用来存放访问内存时的地址。</li>\n<li>CX：寄存器称为计数寄存器，在循环、串操作指令中用作计数器。</li>\n<li>DX：寄存器称为数据寄存器，在寄存器间接寻址中的I/O指令中存放I/O端口的地址。</li>\n</ul>\n<h1 id=\"gnu-as-汇编\">GNU as 汇编<a title=\"#gnu-as-汇编\" href=\"#gnu-as-汇编\"></a></h1>\n<p>以下简称as汇编器，编译一个as汇编语言的基本格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">as [ 选项 ] [ -o objfile ] [ srcfile.s ...]</span><br></pre></td></tr></table></figure>\n<p>采用的是<strong>ATT的汇编语法</strong>， 与<em>Intel</em>的语法很不一样：</p>\n<ul>\n<li>立即操作数加 ‘$’, 寄存器操作数加 ’%‘，绝对跳转/调用操作数加 ‘*’（<strong>相对于与程序计数器有关的跳转/调用</strong>）</li>\n<li>ATT的源和目的操作数是从左到右， 即 ‘源， 目的’。</li>\n<li>ATT内存操作数的长度有操作码的最后一个字符在确定。‘b’, ‘w’ ,'l’分别指示内存引用宽度为8位字节（Byte），16位字节(word)，32位字节(long)。</li>\n<li>立即形式的远跳转和远调用不同</li>\n<li>不提供多代码段的支持</li>\n<li>使用 ‘#’ 来进行单行注释，在预处理的时候会被删除</li>\n</ul>\n<p><em>符号、语句和常数</em></p>\n<p>语句的通用格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">标号: 汇编命令 注释部分(可选) </span><br><span class=\"line\">或</span><br><span class=\"line\">标号: 指令助记符 操作数 1, 操作数 2 注释部分(可选)</span><br></pre></td></tr></table></figure>\n<p>指令语句是CPU执行的操作，也称<em>操作码</em></p>\n<p><em>操作数</em> 是指令操作的对象</p>\n<p><em>地址</em>是指定数据在内存中的位置</p>\n<p>操作数可以<strong>立即数、寄存器、内存</strong></p>\n<p>间接操作数是指<em>含有实际操作数值的地址值</em></p>\n<p>关于<strong>内存引用</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intel 语法的间接内存引用形式:section:[base + index*scale + disp] </span><br><span class=\"line\">AT&amp;T 语法形式:section:disp(base, index, scale)</span><br></pre></td></tr></table></figure>\n<p><em>跳转命令</em>：</p>\n<p><strong>直接跳转语句</strong> 的写法是给出跳转目标处的标号;</p>\n<p><strong>间接跳转语句</strong>的写法是必须使用一个星字符’*'作为操作指示符的前缀 字符，并且该操作指示符使用 movl 指令相同的语法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp NewLoc # 直接跳转。无条件直接跳转到标号 NewLoc 处继续执行。</span><br><span class=\"line\">jmp *%eax # 间接跳转。寄存器%eax 的值是跳转的目标位置。</span><br><span class=\"line\">jmp *(%eax) # 间接跳转。从%eax 指明的地址处读取跳转的目标位置。</span><br></pre></td></tr></table></figure>\n<p>链接器涉及的区只有4类：</p>\n<ul>\n<li>text区</li>\n<li>bss区</li>\n<li>absolute区</li>\n<li>undefined区</li>\n</ul>\n<p><em>符号名</em>以一个字母或 ‘._’字符之一开始</p>\n<p>特殊点 ‘.’ 表示as汇编的当前地址。</p>\n<p><strong>C语言的编译过程</strong>：</p>\n<p>在前处理阶段中，gcc 会把 C 程序传递给 C 前处理器 CPP，对 C 语言程序中指示符和宏进行替换处理， 输出纯 C 语言代码;在编译阶段，gcc 把 C 语言程序编译生成对应的与机器相关的 as 汇编语言代码;在汇 编阶段，as 汇编器会把汇编代码转换成机器指令，并以特定二进制格式输出保存在目标文件中;最后 GNU ld 链接器把程序的相关目标文件组合链接在一起，生成程序的可执行映像文件。</p>\n<p><img src=\"https://raw.githubusercontent.com/lumosmax7/pics/main/uPic/Screen%20Shot%202021-05-25%20at%2010.57.54.png\" alt=\"Screen Shot 2021-05-25 at 10.57.54\" class=\"φbs\"></p>\n<p>gcc的命令行格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -o hello hello.c &#x2F;&#x2F; 编译 hello.c 程序，生成执行文件 hello。</span><br><span class=\"line\">gcc -S -o hello.s hello.c &#x2F;&#x2F; 编译 hello.c 程序，生成对应汇编程序 hello.s。</span><br><span class=\"line\">gcc -c -o hello.o hello.c &#x2F;&#x2F; 编译 hello.c 程序，生成对应目标文件 hello.o 而不链接。</span><br></pre></td></tr></table></figure>\n<p><em>嵌入汇编</em>的基本格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm(“汇编语句” </span><br><span class=\"line\">: 输出寄存器 </span><br><span class=\"line\">: 输入寄存器</span><br><span class=\"line\">: 会被修改的寄存器);</span><br></pre></td></tr></table></figure>\n<h1 id=\"c与汇编相互调用\">C与汇编相互调用<a title=\"#c与汇编相互调用\" href=\"#c与汇编相互调用\"></a></h1>\n<p>大多数CPU上的程序实现使用栈来支持函数调用操作。</p>\n<p><em>栈帧</em> 单个函数调用操作所使用的栈部分被称为栈帧结构，帧指针<strong>ebp</strong></p>\n<p>栈指针<strong>esp</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lumosmax7/pics/main/uPic/Screen%20Shot%202021-05-26%20at%2014.54.16.png\" alt=\"Screen Shot 2021-05-26 at 14.54.16\" class=\"φbs\"></p>\n<p>栈帧结构的两端是由两个指针来指定。</p>\n<p><strong>返回值是一个整数或一个指针，那么寄存器eax将被默认用来传递返回值</strong></p>\n<p><em>寄存器用法统一惯例</em>：</p>\n<ul>\n<li>寄存器eax、edx、ecx的内容必须由调用者自己负责保存。当函数 B 被 A 调用时，函数 B 可以在不用保存这些寄存器内容的情况下任意使用它们而不会毁坏函数 A 所需要的任何数据。</li>\n<li>寄存器 ebx、esi 和 edi 的内容则必须由被调用者 B 来保护。当被调用者需要使 用这些寄存器中的任意一个时，必须首先在栈中保存其内容，并在退出时恢复这些寄存器的内容。因为调用者A(或者一些更高层的函数)并不负责保存这些寄存器内容，但可能在以后的操作中还需要用到原先 的值。</li>\n<li>还有寄存器 ebp 和 esp 也必须遵守第二个惯例用法。</li>\n</ul>\n<p>举例说明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *a,<span class=\"keyword\">int</span> *b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c;</span><br><span class=\"line\">\tc =*a;*a=*b:*b=c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">\ta =<span class=\"number\">16</span>;b=<span class=\"number\">32</span>;</span><br><span class=\"line\">\tswap(&amp;a,&amp;b):</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>(a-b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/lumosmax7/pics/main/uPic/Screen%20Shot%202021-05-26%20at%2015.10.29.png\" alt=\"Screen Shot 2021-05-26 at 15.10.29\" class=\"φbs\"></p>\n<p><strong>汇编语言调用C函数</strong></p>\n<p>首先按照<em>逆向顺序</em>把函数压入栈中</p>\n<p><img src=\"https://raw.githubusercontent.com/lumosmax7/pics/main/uPic/Screen%20Shot%202021-05-29%20at%2009.32.03.png\" alt=\"Screen Shot 2021-05-29 at 09.32.03\" class=\"φbs\"></p>\n<ul>\n<li>a.out 相关</li>\n</ul>\n<p>磁盘上a.out执行文件的各区在进程逻辑地址空间中的对应关系。Linux 0.12系统中进程的逻辑空间大小是64MB。</p>\n<p><img src=\"https://raw.githubusercontent.com/lumosmax7/pics/main/uPic/Screen%20Shot%202021-05-29%20at%2010.21.46.png\" alt=\"Screen Shot 2021-05-29 at 10.21.46\" class=\"φbs\"></p>\n<p>对于a.out格式的模块文件来说，由于段的类型是预先知道，所以其分配的情况如图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/lumosmax7/pics/main/uPic/Screen%20Shot%202021-05-29%20at%2010.24.56.png\" alt=\"Screen Shot 2021-05-29 at 10.24.56\" class=\"φbs\"></p>\n<p>当Linux0.12内核加载一个可执行文件时，它会根据文件头部结构中的信息首先判断文件<strong>是否是一个合适的可执行文件</strong>，即其<strong>魔数类型是否为ZMAGIC</strong>，然后系统在用户态堆栈顶部为程序设置环境参数和命令行上输入的参数信息块并为其构建一个任务数据结构。接着在设置一些相关寄存器值后利用堆栈返回技术去执行程序。执行程序映像文件中的代码和数据将会在实际执行到或用到时利用需求加载技术动态加入到内存中。</p>\n<ul>\n<li>Make文件</li>\n</ul>\n<p>一个Makefile文件可以包括<em>显示规则、隐含规则、变量定义、指示符和注释信息</em></p>\n<p>Makefile的命令标准：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target(目标)...: prerequisites(先决条件)... </span><br><span class=\"line\">\t\t\t\t\t\t\t\tcommand(命令)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t... </span><br><span class=\"line\">\t\t\t\t\t\t\t\t...</span><br></pre></td></tr></table></figure>\n<p>示例</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\">\t\t\tcc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\">main.o : main.c defs.h</span><br><span class=\"line\">        cc -c main.c</span><br><span class=\"line\">kbd.o : kbd.c defs.h command.h</span><br><span class=\"line\">        cc -c kbd.c</span><br><span class=\"line\">command.o : command.c defs.h command.h</span><br><span class=\"line\">        cc -c command.c</span><br><span class=\"line\">display.o : display.c defs.h buffer.h</span><br><span class=\"line\">        cc -c display.c</span><br><span class=\"line\">insert.o : insert.c defs.h buffer.h</span><br><span class=\"line\">        cc -c insert.c</span><br><span class=\"line\">search.o : search.c defs.h buffer.h</span><br><span class=\"line\">        cc -c search.c</span><br><span class=\"line\">files.o : files.c defs.h buffer.h command.h</span><br><span class=\"line\">        cc -c files.c</span><br><span class=\"line\">utils.o : utils.c defs.h</span><br><span class=\"line\">        cc -c utils.c</span><br><span class=\"line\">clean :</span><br><span class=\"line\">\t\t\t\trm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>\n<p>老式双后缀规则：源后缀和目标后缀</p>\n","prev":{"title":"常用矩阵求导","link":"2021/05/26/常用矩阵求导"},"next":{"title":"linuxKernel-2","link":"2021/05/24/linuxKernel-2"},"plink":"http://example.com/2021/05/24/linuxKernel-3/","toc":[{"id":"as86汇编语言的语法","title":"as86汇编语言的语法","index":"1"},{"id":"gnu-as-汇编","title":"GNU as 汇编","index":"2"},{"id":"c与汇编相互调用","title":"C与汇编相互调用","index":"3"}]}